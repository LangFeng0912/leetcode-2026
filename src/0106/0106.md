- [1339. 分裂二叉树的最大乘积](https://leetcode.cn/problems/maximum-product-of-splitted-binary-tree/description/) 计算每颗子树之和：dfs后序遍历 
        
    - 什么时候判空: dfs(null)是否有明确定义，这里dfs(null)明确为0,或者可以**一直不判断，绝大多数情况(路径除外)，在dfs内判空返回**
        - operation: `int sum = leftSum + rightSum + cur.val`
        - 取模时 (int) (a%b)
- [2049. 统计最高分的节点数目](https://leetcode.cn/problems/count-nodes-with-the-highest-score/description/) 计算每颗子数的节点数

    - 根据parent数组构建树：两次遍历
        - 第一次`TreeNode[]` new 每个节点
        - 第二次遍历parents数组，为每一个父节点加入子节点
    - operation: `int num = leftNum + rightNum + 1`
    - dfs后序遍历时，注意乘法用`long`
- 比较好的做法：先得到total，要么dfs获取整颗树的总和或者直接n，然后dfs时用冒泡直接获取结果